## We store the solution for a matrix to avoid re-calculating it.

## Create a "wrapper" for a matrix so its inverse can be cached.

makeCacheMatrix <- function(x = matrix()) {
  
  # 'i' as in inverse
  i <- NULL
  
  # when the matrix is stored into this special wrapper we make sure
  # the stored value for the inverse is reset to null.
  set <- function(y) {
    x <<- y
    i <<- NULL
  }
  
  get <- function() {
    x
  }
  
  setInverse <- function(inverse) {
    i <<- inverse;
  }
  
  getInverse <- function() {
    i
  }
  
  # return this wrapper as a list
  list(set=set, get=get, setInverse=setInverse, getInverse=getInverse)
}


## Solve the special matrix generated by makeCacheMatrix() or retrieve
## the solution from cache if available.

cacheSolve <- function(x, ...) {
  # try to get the return value from cache
  ret <- x$getInverse()

  # if the cache was empty then calculate the value and store it into cache
  if (is.null(ret)) {
    ret <- solve(x$get())
    x$setInverse(ret)
  }

    ret
}
